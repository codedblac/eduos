from django.utils import timezone
from datetime import timedelta
from celery import shared_task
from django.db.models import Avg

from .models import (
    Assessment, AssessmentSession, AssessmentLock, RetakePolicy,
    PerformanceTrend, Student, Subject, AssessmentTemplate
)
from notifications.utils import send_notification
from assessments.utils import generate_assessment_from_template


@shared_task
def auto_generate_assessments():
    """
    Periodically auto-generates assessments from active templates.
    Focused on remote/digital delivery; typically scheduled via Celery beat.
    """
    now = timezone.now()
    templates = AssessmentTemplate.objects.filter(is_active=True)

    for template in templates:
        subject = template.type.subject_set.first()
        if not subject:
            continue

        for class_level in subject.class_levels.all():
            assessment = generate_assessment_from_template(
                template=template,
                subject=subject,
                class_level=class_level,
                scheduled_date=now + timedelta(days=2)
            )
            print(f"[AutoGenerated] {assessment}")


@shared_task
def disburse_assessments():
    """
    Notifies students about upcoming assessments (within 6 hours).
    Also applicable for scheduling print jobs in hybrid delivery environments.
    """
    now = timezone.now()
    assessments = Assessment.objects.filter(
        is_published=True,
        scheduled_date__lte=now + timedelta(hours=6),
        scheduled_date__gte=now
    )

    for assessment in assessments:
        sessions = AssessmentSession.objects.filter(assessment=assessment)
        for session in sessions:
            send_notification(
                user=session.student.user,
                title="Upcoming Assessment",
                message=f"You have '{assessment.title}' scheduled soon."
            )


@shared_task
def lock_past_due_assessments():
    """
    Automatically locks assessments past their scheduled deadline.
    Prevents late submissions unless explicitly reopened by staff.
    """
    now = timezone.now()
    assessments = Assessment.objects.filter(scheduled_date__lt=now)

    for assessment in assessments:
        lock, _ = AssessmentLock.objects.get_or_create(assessment=assessment)
        if not lock.locked:
            lock.locked = True
            lock.locked_at = now
            lock.reason = "Submission window expired"
            lock.save()


@shared_task
def enforce_retake_policies():
    """
    Enforces configured retake policies based on cooldown and max attempts.
    Students exceeding policy limits are prevented from further submissions.
    """
    for policy in RetakePolicy.objects.select_related("assessment"):
        total_attempts = AssessmentSession.objects.filter(
            assessment=policy.assessment,
            student__in=Student.objects.all()
        ).count()

        if total_attempts >= policy.max_attempts:
            AssessmentLock.objects.update_or_create(
                assessment=policy.assessment,
                defaults={
                    "locked": True,
                    "reason": "Maximum retake attempts exceeded"
                }
            )


@shared_task
def update_performance_trends():
    """
    Aggregates student performance trends per subject and term.
    Used for academic dashboards and student growth tracking.
    """
    students = Student.objects.all()
    subjects = Subject.objects.all()

    for student in students:
        for subject in subjects:
            sessions = AssessmentSession.objects.filter(
                student=student,
                assessment__subject=subject,
                is_graded=True
            )
            if sessions.exists():
                avg_score = sessions.aggregate(avg=Avg('score'))['avg']
                count = sessions.count()
                latest_term = sessions.order_by('-started_at').first().assessment.term

                PerformanceTrend.objects.update_or_create(
                    student=student,
                    subject=subject,
                    term=latest_term,
                    defaults={
                        "average_score": avg_score,
                        "assessment_count": count,
                    }
                )
