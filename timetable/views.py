from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from django.http import FileResponse, Http404
from django.shortcuts import get_object_or_404
from .models import Room, SubjectAssignment, TimetableEntry
from .serializers import RoomSerializer, SubjectAssignmentSerializer, TimetableEntrySerializer
from .permissions import IsSuperAdmin, CanManageTimetable, CanViewOwnTimetable
from teachers.models import Teacher
from classes.models import Stream
from .timetable_engine import generate_ai_timetable
from .pdf_generator import generate_timetable_pdf
import logging
import io

logger = logging.getLogger(__name__)

# --- Room Views ---
class RoomListCreateView(generics.ListCreateAPIView):
    queryset = Room.objects.all()
    serializer_class = RoomSerializer
    permission_classes = [permissions.IsAuthenticated, CanManageTimetable]


class RoomRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Room.objects.all()
    serializer_class = RoomSerializer
    permission_classes = [permissions.IsAuthenticated, CanManageTimetable]


# --- SubjectAssignment Views ---
class SubjectAssignmentListCreateView(generics.ListCreateAPIView):
    queryset = SubjectAssignment.objects.all()
    serializer_class = SubjectAssignmentSerializer
    permission_classes = [permissions.IsAuthenticated, CanManageTimetable]


class SubjectAssignmentRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
    queryset = SubjectAssignment.objects.all()
    serializer_class = SubjectAssignmentSerializer
    permission_classes = [permissions.IsAuthenticated, CanManageTimetable]


# --- TimetableEntry Views ---
class TimetableEntryListView(generics.ListAPIView):
    serializer_class = TimetableEntrySerializer
    permission_classes = [permissions.IsAuthenticated, CanViewOwnTimetable]

    def get_queryset(self):
        user = self.request.user
        if user.role == 'teacher':
            # Return only entries for this teacher
            return TimetableEntry.objects.filter(teacher__user=user)
        elif user.role in ['admin', 'superadmin']:
            # Return all timetable entries for admins
            return TimetableEntry.objects.all()
        elif user.role == 'student':
            # Students see timetable of their stream/class
            if hasattr(user, 'student_profile') and user.student_profile.stream:
                return TimetableEntry.objects.filter(stream=user.student_profile.stream)
        return TimetableEntry.objects.none()


class TimetableEntryRetrieveView(generics.RetrieveAPIView):
    queryset = TimetableEntry.objects.all()
    serializer_class = TimetableEntrySerializer
    permission_classes = [permissions.IsAuthenticated, CanViewOwnTimetable]


# --- AI-Powered Timetable Generation ---
class GenerateAITimetableView(APIView):
    permission_classes = [permissions.IsAuthenticated, IsSuperAdmin]

    def post(self, request):
        try:
            generate_ai_timetable()

            # After generation, optionally associate timetable entries to teacher profiles
            # (They are already linked via FK in TimetableEntry)

            logger.info(f"AI Timetable generated by {request.user.email}")
            return Response({"detail": "AI Timetable generated successfully."}, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"AI Timetable generation failed: {str(e)}")
            return Response({"error": "Failed to generate timetable", "details": str(e)}, status=status.HTTP_400_BAD_REQUEST)


# --- Timetable PDF Download Views ---

class DownloadStreamTimetablePDF(APIView):
    permission_classes = [permissions.IsAuthenticated, CanViewOwnTimetable]

    def get(self, request, stream_id):
        stream = get_object_or_404(Stream, id=stream_id)
        user = request.user

        # Permission check: user must belong to the same institution or be superuser
        if not user.is_superuser and getattr(user, 'institution', None) != stream.institution:
            return Response({"error": "Not permitted to access this stream timetable."}, status=status.HTTP_403_FORBIDDEN)

        entries = TimetableEntry.objects.filter(stream=stream).select_related('subject', 'teacher', 'room')

        if not entries.exists():
            return Response({"error": "No timetable entries found for this stream."}, status=status.HTTP_404_NOT_FOUND)

        institution = getattr(stream, 'institution', None)
        if not institution:
            return Response({"error": "Institution info not found for stream."}, status=status.HTTP_400_BAD_REQUEST)

        days = getattr(institution, 'timetable_days', ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'])
        periods_per_day = getattr(institution, 'periods_per_day', 7)

        pdf_buffer = io.BytesIO()
        generate_timetable_pdf(pdf_buffer, entries, title=f"Timetable for {stream.name}", days=days, periods_per_day=periods_per_day)
        pdf_buffer.seek(0)

        filename = f"timetable_{stream.name}.pdf"
        return FileResponse(pdf_buffer, as_attachment=True, filename=filename, content_type='application/pdf')


class DownloadTeacherTimetablePDF(APIView):
    permission_classes = [permissions.IsAuthenticated, CanViewOwnTimetable]

    def get(self, request, teacher_id=None):
        user = request.user

        if teacher_id is None:
            try:
                teacher = user.teacher_profile
            except Teacher.DoesNotExist:
                return Response({"error": "Teacher profile not found."}, status=status.HTTP_404_NOT_FOUND)
        else:
            teacher = get_object_or_404(Teacher, id=teacher_id)
            if not user.is_superuser and teacher.user != user:
                return Response({"error": "Not permitted to access this teacher timetable."}, status=status.HTTP_403_FORBIDDEN)

        entries = TimetableEntry.objects.filter(teacher=teacher).select_related('subject', 'stream', 'room')

        if not entries.exists():
            return Response({"error": "No timetable entries found for this teacher."}, status=status.HTTP_404_NOT_FOUND)

        institution = None
        if hasattr(teacher, 'streams') and teacher.streams.exists():
            institution = teacher.streams.first().institution
        elif hasattr(teacher, 'institution'):
            institution = teacher.institution

        days = getattr(institution, 'timetable_days', ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'])
        periods_per_day = getattr(institution, 'periods_per_day', 7)

        pdf_buffer = io.BytesIO()
        generate_timetable_pdf(pdf_buffer, entries, title=f"Timetable for {teacher.first_name} {teacher.last_name}", days=days, periods_per_day=periods_per_day)
        pdf_buffer.seek(0)

        filename = f"timetable_{teacher.first_name}_{teacher.last_name}.pdf"
        return FileResponse(pdf_buffer, as_attachment=True, filename=filename, content_type='application/pdf')
